syntax = "proto3";
package eraftpb;


// The entry is a type of change that needs to be applied. 
// normal entries, the data field should contain the data change that should be applied.
// The context field can be used for any contextual data that might be relevant to the
// application of the data.
message Entry {
    // current term
    uint64 term = 1;
    // entry index
    uint64 index = 2;
    // entry context
    bytes data = 3;
}

// `HardState` contains the state of a node need to be peristed, including the current term, commit index
// and the vote record
message HardState {
    // the current term
    uint64 term = 1;
    // who is this node voted for in the current term
    uint64 voted_for = 2;
    // the committed log index
    uint64 committed = 3;
    // the applied log index
    uint64 applied = 4;
}

// `ConfState` contains the current membership information of the raft group
message ConfState {
    // all node id
    repeated uint64 peers = 1;
}

// Message definition 
message Message {
    oneof msg_data {
        // `MsgHup` is a local message used for election. If an election timeout happened,
	    // the node should pass `MsgHup` to its Step method and start a new election.
        MsgHup hup = 1;
        // `MsgBeat' is a local message that signals the leader to send a heartbeat
	    // of the `MsgBeat` type to its followers.
        MsgBeat beat = 2;
        // `MsgPropose` is a local message that proposes to append data to the leader's log entries.
        MsgPropose propose = 3;
        // `MsgAppend` contains log entries to replicate.
        MsgAppend append = 4;
        // `MsgHeartbeat` sends heartbeat from leader to its followers.
        MsgHeartbeat heartbeat = 5;
        // `MsgRequestVote` requests votes for election.
        MsgRequestVote request_vote = 6;
        // `MsgAppendResponse' is response to log replication request(`MsgAppend`).
        MsgAppendResponse append_response = 7;
        // `MsgHeartbeatResponse` is a response to `MsgHeartbeat`.
        MsgHeartbeatResponse heartbeat_response = 8;
        // `MsgRequestVoteResponse` contains responses from voting request.
        MsgRequestVoteResponse request_vote_response = 9;
    }
}

// `MsgHup` is used for election. If a node is a follower or candidate, the
// `tick` function in `raft` struct is set as `tickElection`. If a follower or
// candidate has not received any heartbeat before the election timeout, it
// passes `MsgHup` to its Step method and becomes (or remains) a candidate to
// start a new election.
message MsgHup {
    // sender id
    uint64 from = 1;
    // receiver id
    uint64 to = 2;
}

// `MsgBeat` is an internal type that signals the leader to send a heartbeat of
// the `MsgHeartbeat` type. If a node is a leader, the `tick` function in
// the raft struct is set as `tickHeartbeat`, and triggers the leader to
// send periodic `MsgHeartbeat` messages to its followers. 
message MsgBeat {
    // sender id
    uint64 from = 1;
    // receiver id
    uint64 to = 2;
}


// `MsgPropose` proposes to append data to its log entries. This is a special
// type to redirect proposals to the leader. Therefore, send method overwrites
// eraftpb.Message's term with its `HardState`'s term to avoid attaching its
// local term to `MsgPropose`. When `MsgPropose` is passed to the leader's `Step`
// method, the leader first calls the `AppendEntry` method to append entries
// to its log, and then calls `bcastAppend` method to send those entries to
// its peers. When passed to candidate, `MsgPropose` is dropped. When passed to
// follower, `MsgPropose` is stored in follower's mailbox(msgs) by the send
// method. It is stored with sender's ID and later forwarded to the leader by
// rafthttp package.
message MsgPropose {
    // sender id
    uint64 from = 1;
    // receiver id
    uint64 to = 2;
    // proposals
    repeated Entry entries = 3;
}

// `MsgAppend` contains log entries to replicate. A leader calls bcastAppend,
// which calls sendAppend, which sends soon-to-be-replicated logs in `MsgAppend`
// type. When `MsgAppend` is passed to candidate's Step method, candidate reverts
// back to follower, because it indicates that there is a valid leader sending
// `MsgAppend` messages. Candidate and follower respond to this message in
// `MsgAppendResponse` type.
message MsgAppend {
    // sender id
    uint64 from = 1;
    // receiver id
    uint64 to = 2;
    // current term
    uint64 term = 3;
    // commit index
    uint64 leader_commit = 4;
    // the prev log index of the leader, for consistency check
    uint64 prev_log_index = 5;
    // the prev log term of the leader, for consistency check
    uint64 prev_log_term = 6;
    // log entries
    repeated Entry entries = 7;
}

// `MsgAppendResponse` is response to log replication request(`MsgAppend`). When
// `MsgAppend` is passed to candidate or follower's Step method, it responds by
// calling `handleAppendEntries` method, which sends `MsgAppendResponse` to raft
// mailbox.
message MsgAppendResponse {
    // sender id
    uint64 from = 1;
    // receiver id
    uint64 to = 2;
    // current term
    uint64 term = 3;
    // reject AppendReuqeust or not
    bool reject = 4; 
    // the last log index of the follower
    uint64 last_log_index = 5;
    // last log term of the follower
    uint64 last_log_term = 6;
    
}

// `MsgRequestVote` requests votes for election. When a node is a follower or
// candidate and `MsgHup` is passed to its Step method, then the node calls
// `campaign` method to campaign itself to become a leader. Once `campaign`
// method is called, the node becomes candidate and sends `MsgRequestVote` to peers
// in cluster to request votes. When passed to the leader or candidate's Step
// method and the message's Term is lower than leader's or candidate's,
message MsgRequestVote {
    // sender id
    uint64 from = 1;
    // receiver id
    uint64 to = 2;
    // current term
    uint64 term = 3;
    // the last log index of the candidate
    uint64 last_log_index = 4;
    // the last log term of the candidate
    uint64 last_log_term = 5;
    
}

// `MsgRequestVoteResponse` contains responses from voting request. When `MsgRequestVoteResponse` is
// passed to candidate, the candidate calculates how many votes it has won. If
// it's more than majority (quorum), it becomes leader and calls `bcastAppend`.
// If candidate receives majority of votes of denials, it reverts back to
// follower.
message MsgRequestVoteResponse {
    // sender id
    uint64 from = 1; 
    // receiver id
    uint64 to = 2;
    // sender's current term
    uint64 term = 3;
    // reject the voted request or not
    bool reject = 4;
}



// `MsgHeartbeat` sends heartbeat from leader. When `MsgHeartbeat` is passed
// to candidate and message's term is higher than candidate's, the candidate
// reverts back to follower and updates its committed index from the one in
// this heartbeat. And it sends the message to its mailbox. When
// `MsgHeartbeat` is passed to follower's Step method and message's term is
// higher than follower's, the follower updates its `leaderID` with the ID
// from the message.
message MsgHeartbeat {
    // sender id
    uint64 from = 1;
    // receiver id
    uint64 to = 2; 
    // leader's current term
    uint64 term = 3;
}

// `MsgHeartbeatResponse` is a response to `MsgHeartbeat`. When `MsgHeartbeatResponse`
// is passed to the leader's Step method, the leader knows which follower
// responded.
message MsgHeartbeatResponse {
    // sender id
    uint64 from = 1;
    // receiver id
    uint64 to = 2;
    // follower's current term
    uint64 term = 3;
    // check whether the leader is stale or not. 
    // return true if the leader's term is less than peer's
    bool reject = 4;
}
